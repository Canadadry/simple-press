package sqlutil

import (
	"context"
	"reflect"
	"testing"
)

func notNull(ctx context.Context, ids [50]int32) ([]int32, error) {
	out := make([]int32, 0, sliceSize)
	for _, val := range ids {
		if val != 0 {
			out = append(out, val)
		}
	}
	return out, nil
}

func TestAsArray(t *testing.T) {
	tests := map[string]struct {
		in  []int32
		out [][sliceSize]int32
	}{
		"nil": {
			in:  nil,
			out: [][sliceSize]int32{},
		},
		"empty": {
			in:  []int32{},
			out: [][sliceSize]int32{},
		},
		"lessThanSliceSize": {
			in: []int32{1, 2, 3},
			out: [][sliceSize]int32{
				{
					1, 2, 3, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				},
			},
		},
		"moreThanSliceSize": {
			in: []int32{
				1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
				1, 2, 3, 4, 5, 6, 7, 8, 9, 11,
				1, 2, 3, 4, 5, 6, 7, 8, 9, 12,
				1, 2, 3, 4, 5, 6, 7, 8, 9, 13,
				1, 2, 3, 4, 5, 6, 7, 8, 9, 14,
				1, 2, 3, 4, 5, 6, 7, 8, 9, 15,
			},
			out: [][sliceSize]int32{
				{
					1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
					1, 2, 3, 4, 5, 6, 7, 8, 9, 11,
					1, 2, 3, 4, 5, 6, 7, 8, 9, 12,
					1, 2, 3, 4, 5, 6, 7, 8, 9, 13,
					1, 2, 3, 4, 5, 6, 7, 8, 9, 14,
				},
				{
					1, 2, 3, 4, 5, 6, 7, 8, 9, 15,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				},
			},
		},
		"moreThanThreeSliceSize": {
			in: []int32{
				1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
				1, 2, 3, 4, 5, 6, 7, 8, 9, 11,
				1, 2, 3, 4, 5, 6, 7, 8, 9, 12,
				1, 2, 3, 4, 5, 6, 7, 8, 9, 13,
				1, 2, 3, 4, 5, 6, 7, 8, 9, 14,

				1, 2, 3, 4, 5, 6, 7, 8, 9, 20,
				1, 2, 3, 4, 5, 6, 7, 8, 9, 21,
				1, 2, 3, 4, 5, 6, 7, 8, 9, 22,
				1, 2, 3, 4, 5, 6, 7, 8, 9, 23,
				1, 2, 3, 4, 5, 6, 7, 8, 9, 24,

				1, 2, 3, 4, 5, 6, 7, 8, 9, 30,
				1, 2, 3, 4, 5, 6, 7, 8, 9, 31,
				1, 2, 3, 4, 5, 6, 7, 8, 9, 32,
				1, 2, 3, 4, 5, 6, 7, 8, 9, 33,
				1, 2, 3, 4, 5, 6, 7, 8, 9, 34,

				1, 2, 3, 4, 5, 6, 7, 8, 9, 40,
			},
			out: [][sliceSize]int32{
				{
					1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
					1, 2, 3, 4, 5, 6, 7, 8, 9, 11,
					1, 2, 3, 4, 5, 6, 7, 8, 9, 12,
					1, 2, 3, 4, 5, 6, 7, 8, 9, 13,
					1, 2, 3, 4, 5, 6, 7, 8, 9, 14,
				},
				{
					1, 2, 3, 4, 5, 6, 7, 8, 9, 20,
					1, 2, 3, 4, 5, 6, 7, 8, 9, 21,
					1, 2, 3, 4, 5, 6, 7, 8, 9, 22,
					1, 2, 3, 4, 5, 6, 7, 8, 9, 23,
					1, 2, 3, 4, 5, 6, 7, 8, 9, 24,
				},
				{
					1, 2, 3, 4, 5, 6, 7, 8, 9, 30,
					1, 2, 3, 4, 5, 6, 7, 8, 9, 31,
					1, 2, 3, 4, 5, 6, 7, 8, 9, 32,
					1, 2, 3, 4, 5, 6, 7, 8, 9, 33,
					1, 2, 3, 4, 5, 6, 7, 8, 9, 34,
				},
				{
					1, 2, 3, 4, 5, 6, 7, 8, 9, 40,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				},
			},
		},
	}
	for name, tt := range tests {
		t.Run(name, func(t *testing.T) {
			result := AsArray(tt.in)
			if !reflect.DeepEqual(result, tt.out) {
				t.Fatalf("failed got %v want %v", result, tt.out)
			}
		})
	}
}

func TestGetList(t *testing.T) {
	tests := map[string]struct {
		in  []int32
		out []int32
	}{
		"nil": {
			in:  nil,
			out: []int32{},
		},
		"empty": {
			in:  []int32{},
			out: []int32{},
		},
		"lessThan50": {
			in:  []int32{1, 2, 3},
			out: []int32{1, 2, 3},
		},
		"moreThan50": {
			in:  []int32{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 13, 1, 2, 3, 4, 5, 6, 7, 8, 9, 14, 1, 2, 3, 4, 5, 6, 7, 8, 9, 15},
			out: []int32{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 13, 1, 2, 3, 4, 5, 6, 7, 8, 9, 14, 1, 2, 3, 4, 5, 6, 7, 8, 9, 15},
		},
		"moreThan150": {
			in: []int32{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 13, 1, 2, 3, 4, 5, 6, 7, 8, 9, 14, 1, 2, 3, 4, 5, 6, 7, 8, 9, 151,
				1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 13, 1, 2, 3, 4, 5, 6, 7, 8, 9, 14, 1, 2, 3, 4, 5, 6, 7, 8, 9, 152,
				1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 13, 1, 2, 3, 4, 5, 6, 7, 8, 9, 14, 1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 154},
			out: []int32{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 13, 1, 2, 3, 4, 5, 6, 7, 8, 9, 14, 1, 2, 3, 4, 5, 6, 7, 8, 9, 151,
				1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 13, 1, 2, 3, 4, 5, 6, 7, 8, 9, 14, 1, 2, 3, 4, 5, 6, 7, 8, 9, 152,
				1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 13, 1, 2, 3, 4, 5, 6, 7, 8, 9, 14, 1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 154},
		},
	}
	for name, tt := range tests {
		t.Run(name, func(t *testing.T) {
			result, err := GetListBy50(context.TODO(), tt.in, notNull)
			if err != nil {
				t.Fatalf("failed %v", err)
			}
			if !reflect.DeepEqual(result, tt.out) {
				t.Fatalf("failed got %v want %v", result, tt.out)
			}
		})
	}
}
