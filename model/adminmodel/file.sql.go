// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: file.sql

package adminmodel

import (
	"context"
)

const deleteFile = `-- name: DeleteFile :exec
DELETE FROM files
WHERE
    uuid = ?
`

func (q *Queries) DeleteFile(ctx context.Context, uuid string) error {
	_, err := q.db.ExecContext(ctx, deleteFile, uuid)
	return err
}

const downloadFile = `-- name: DownloadFile :one
SELECT
    content
FROM
    files
WHERE
    uuid = ?
LIMIT
    1
`

func (q *Queries) DownloadFile(ctx context.Context, uuid string) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, downloadFile, uuid)
	var content []byte
	err := row.Scan(&content)
	return content, err
}

const getFileList = `-- name: GetFileList :many
SELECT
    uuid,
    name
FROM
    files
ORDER BY
    id DESC
LIMIT
    ?
OFFSET
    ?
`

type GetFileListParams struct {
	Limit  int64
	Offset int64
}

type GetFileListRow struct {
	Uuid string
	Name string
}

func (q *Queries) GetFileList(ctx context.Context, arg GetFileListParams) ([]GetFileListRow, error) {
	rows, err := q.db.QueryContext(ctx, getFileList, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFileListRow
	for rows.Next() {
		var i GetFileListRow
		if err := rows.Scan(&i.Uuid, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const uploadFile = `-- name: UploadFile :execlastid
INSERT INTO
    files (name, content, uuid)
VALUES
    (?, ?, ?)
`

type UploadFileParams struct {
	Name    string
	Content []byte
	Uuid    string
}

func (q *Queries) UploadFile(ctx context.Context, arg UploadFileParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, uploadFile, arg.Name, arg.Content, arg.Uuid)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}
